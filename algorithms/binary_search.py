#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Бинарный поиск
"""

# ######################################################################################################################
# Импорт необходимых инструментов
# ######################################################################################################################

# Подавление Warning
import warnings
for warn in [UserWarning, FutureWarning]: warnings.filterwarnings('ignore', category = warn)

import math

from typing import List, Tuple, Union, Optional # Типы данных

# ######################################################################################################################
# Бинарный поиск
# ######################################################################################################################

def round_math(val: Union[int, float]) -> int:
    """Округление чисел по математическому закону

    Args:
        val (Union[int, float]): Число для округления

    Returns:
         int: Округленное число
    """

    modf = math.modf(val)

    if modf[0] >= 0.5: res = modf[1] + 1
    else: res = math.ceil(modf[1])

    return int(res)

def binary_search(l: Union[List[int], range], item: int, out: bool = True) -> Optional[Tuple[int, int]]:
    """Бинарный поиск

    Args:
        l (Union[List[int], range]): Список чисел
        item (int): Искомое число
        out (bool): Отображение

    Returns:
        Optional[Tuple[int, int]]: Кортеж:

            1. Искомое число
            2. Индекс искомого числа в списке
    """

    low = 0 # Старт поиска
    high = len(l) - 1 # Конец поиска

    res = None # Результат
    cnt = 0 # Счетчик

    while low <= high:
        cnt += 1

        mid = int((high - low) / 2 + low) # Индекс среднего значения в списке

        guess = l[mid] # Число

        if guess == item: res = (guess, mid); break # Число соответствует искомому
        elif guess > item: high = mid - 1 # Число больше искомого
        else: low = mid + 1 # Число меньше искомого

    if not res: res = low

    if out:
        try: print(f'Искомое число ({res[0]}) находится по индексу ({res[1]}), итераций: {cnt}')
        except TypeError: print(f'Искомое число ({item}) не найдено, должно иметь индекс ({res}), итераций: {cnt}')

    return res

# ######################################################################################################################
# Выполняем только в том случае, если файл запущен сам по себе
# ######################################################################################################################

if __name__ == "__main__":
    lists = [
        ([1, 2, 3, 4, 5, 6, 7, 8], 3),
        ([1, 2, 3, 4, 5, 6, 7, 8], 9),
        ([1, 2, 3, 4, 5, 6, 7, 8], 15),
        ([1, 2, 3, 4, 5, 6, 7, 8], 0),
        ([2, 3, 4, 5, 6, 7, 8], 0),
        ([2, 5], 0),
        ([], 0)
    ]

    for curr in lists: binary_search(curr[0], curr[1])